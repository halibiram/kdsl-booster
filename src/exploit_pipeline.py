import logging
from unittest.mock import MagicMock

from src.dslam_detector import UniversalDSLAMDetector
from src.reporting import ReportGenerator
from src.database_manager import DatabaseManager
from src.vulnerability_scanner import VulnerabilityScanner
from src.advanced_dsl_physics import AdvancedDSLPhysics
from src.spoofing import KernelDSLManipulator
from src.keenetic_dsl_interface import KeeneticDSLInterface

class ExploitPipeline:
    """
    Orchestrates the end-to-end automated DSL exploitation process, from
    detection and scanning to exploit execution and validation.
    """

    def __init__(self, target_ip: str, community_string: str, signature_file: str, target_rate_mbps: float = 125.0):
        self.target_ip = target_ip
        self.community_string = community_string
        self.target_rate_mbps = target_rate_mbps
        self.ssh_interface = None  # Must be set before running
        self.final_report = {}

        logging.info("Initializing exploit pipeline components...")
        self.db_manager = DatabaseManager(signature_file_path=signature_file)
        self.detector = UniversalDSLAMDetector(self.ssh_interface, self.db_manager)
        self.scanner = VulnerabilityScanner(self.db_manager)
        self.physics = AdvancedDSLPhysics(profile='17a') # Default profile
        logging.info("Pipeline components initialized.")

    def _execute_kernel_manipulation(self, exploit_info: dict) -> dict:
        """Handles kernel-level manipulation exploits."""
        print(f"--- Executing Kernel Manipulation: {exploit_info['name']} ---")
        try:
            # The SSH mock is already configured in the `run` method to handle
            # the necessary commands for model detection and driver discovery.
            manipulator = KernelDSLManipulator(self.ssh_interface, profile='17a')

            # Calculate optimal distance for the target rate.
            target_distance_m = 50 # Assume a close distance for high speed

            # Execute the manipulation
            result = manipulator.set_target_profile(
                target_rate_mbps=self.target_rate_mbps,
                target_distance_m=target_distance_m
            )
            return result
        except Exception as e:
            logging.error(f"Kernel manipulation failed: {e}", exc_info=True)
            return {"error": str(e)}

    def _validate_outcome(self, execution_result: dict) -> bool:
        """Validates if the exploit was successful."""
        print("--- Validating Outcome ---")
        if not execution_result or execution_result.get("error"):
            print("‚ùå Validation Failed: Exploit execution resulted in an error.")
            return False

        if execution_result.get("snr_margin_set") is True:
            print("‚úÖ Validation Successful: SNR margin was set correctly.")
            return True

        print("‚ùå Validation Failed: Success condition not met.")
        return False

    def _configure_mocks(self):
        """Sets up all necessary mocks for a demonstration run."""
        if not isinstance(self.ssh_interface, MagicMock):
            return

        print("[INFO] Configuring mock SSH interface for demonstration run...")

        # Mock non-SSH analyzers directly
        ghs_analysis_mock = {"vendor_id": "HWTC", "vsi": b"MA5608T", "handshake_duration": 200}
        self.detector.ghs_analyzer.analyze_capture = MagicMock(return_value=ghs_analysis_mock)
        self.detector.dns_analyzer.get_hostname_by_ip = MagicMock(return_value="dslam-ma5608t.isp.com")
        self.detector.dhcp_analyzer.capture_and_analyze = MagicMock(return_value=None)
        self.detector.tr069_analyzer.capture_and_analyze = MagicMock(return_value=None)

        # Define a side_effect function to handle different SSH commands
        def mock_ssh_executor(command, timeout=None):
            logging.info(f"Mock SSH executing: '{command}'")
            # Mock for SNMP detection
            if "snmpget" in command and "1.3.6.1.2.1.1.2.0" in command:
                return "1.3.6.1.4.1.2011", "" # Return the sysObjectID for Huawei
            # Mock for Keenetic model detection (for kernel manipulation)
            if "cat /proc/device-tree/model" in command:
                return "Keenetic Giga (KN-1010)", ""
            # Mock for Broadcom driver discovery (for kernel manipulation)
            if "command -v xdslctl" in command:
                return "/usr/bin/xdslctl", ""
            # Mock for setting SNR margin
            if "xdslctl configure --snr" in command:
                return "", "" # Successful execution returns no output
            # Default empty response
            return "", ""

        self.ssh_interface.execute_command.side_effect = mock_ssh_executor

    def run(self):
        """Executes the full exploitation pipeline."""
        print("üöÄ Starting Automated Exploitation Pipeline üöÄ")

        # This must be done after the ssh_interface is assigned in main.py
        self.detector.ssh = self.ssh_interface
        self._configure_mocks()

        # Step 1: Automated DSLAM Detection
        print(f"\n[Step 1] Running multi-method vendor identification for target: {self.target_ip}...")
        detection_result = self.detector.identify_vendor(methods=['g_hs', 'snmp', 'dns', 'timing'])
        if not detection_result or 'primary_vendor' not in detection_result:
            print("‚ùå DSLAM detection failed. Aborting pipeline.")
            return
        vendor = detection_result['primary_vendor']
        print(f"‚úÖ DSLAM Detected: {vendor} with confidence {detection_result['overall_confidence']}%")
        self.final_report['detection'] = detection_result

        # Step 2: Vulnerability Scanning & Exploit Selection
        print("\n[Step 2] Scanning for vulnerabilities and selecting exploit...")
        selected_exploit = self.scanner.select_exploit(vendor, detection_result.get('capability_analysis', {}))
        if not selected_exploit:
            print("‚ùå No suitable exploit found. Aborting pipeline.")
            return
        print(f"‚úÖ Exploit Selected: {selected_exploit['name']}")
        self.final_report['exploit'] = selected_exploit

        # Step 3: Parameter Calculation is integrated into the execution step for this PoC.
        print("\n[Step 3] Parameter calculation will be performed during execution.")

        # Step 4: Exploit Execution
        print("\n[Step 4] Executing selected exploit...")
        execution_result = {}
        if selected_exploit['type'] == 'kernel_manipulation':
            execution_result = self._execute_kernel_manipulation(selected_exploit)
        else:
            print(f"‚ùå Exploit type '{selected_exploit['type']}' is not yet supported.")
            execution_result = {"error": "Unsupported exploit type"}
        self.final_report['execution'] = execution_result

        # Step 5: Validation and Rollback
        print("\n[Step 5] Validating exploit outcome...")
        is_successful = self._validate_outcome(execution_result)
        self.final_report['validation'] = {"success": is_successful}
        if not is_successful:
            print("[INFO] Rollback would be triggered here in a real scenario.")

        # Step 6: Reporting
        print("\n[Step 6] Generating final report...")
        self.report_generator = ReportGenerator(self.final_report)
        print("\n" + "="*20 + " FINAL TEXT REPORT " + "="*20)
        print(self.report_generator.generate_text_report())
        print("\n" + "="*20 + " FINAL JSON REPORT " + "="*20)
        print(self.report_generator.generate_json_report())

        print("\nüéâ Automated Exploitation Pipeline Complete üéâ")