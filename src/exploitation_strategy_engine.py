import logging
from typing import Dict, Any, List

class ExploitationStrategyEngine:
    """
    AI-driven engine to select the optimal DSL exploitation strategy based on
    DSLAM characteristics, line conditions, and historical success rates.
    """

    def __init__(self, db_manager: 'DatabaseManager', dslam_info: Dict[str, Any]):
        """
        Initializes the strategy engine.

        Args:
            db_manager: An instance of DatabaseManager to access historical data.
            dslam_info: A dictionary containing information about the detected DSLAM.
        """
        self.db_manager = db_manager
        self.dslam_info = dslam_info
        self.logger = logging.getLogger(self.__class__.__name__)
        self.logger.info("Exploitation Strategy Engine initialized.")

    def select_strategy(self, line_characteristics: Dict[str, Any], stealth_mode: bool = False) -> Dict[str, Any]:
        """
        Selects the best exploitation strategy by scoring potential candidates
        based on rules, historical success rates, and stealth requirements.
        """
        vendor = self.dslam_info.get('primary_vendor', 'unknown').lower()
        model = self.dslam_info.get('model', 'unknown').lower()
        self.logger.info(f"Selecting strategy for DSLAM: {vendor} {model} | Stealth Mode: {stealth_mode}")

        # 1. Get historical success rates
        success_rates = self.db_manager.get_strategy_success_rates()
        self.logger.info(f"Loaded success rates for {len(success_rates)} strategies.")

        # 2. Generate all potential candidate strategies
        candidates = []
        if 'huawei' in vendor:
            # The create method returns one of two strategies based on stealth_mode
            candidates.append(self._create_huawei_ma5608t_strategy(stealth_mode))
            candidates.append(self._create_default_huawei_strategy(stealth_mode))
        elif 'nokia' in vendor or 'alcatel' in vendor:
            candidates.append(self._create_nokia_alcatel_strategy(stealth_mode))

        candidates.append(self._create_generic_strategy())

        # 3. Score candidates and select the best one
        best_strategy = self._score_and_select_best_strategy(candidates, success_rates, stealth_mode)
        self.logger.info(f"Selected best strategy: '{best_strategy['name']}' with score {best_strategy['score']:.2f}")

        return best_strategy

    def _score_and_select_best_strategy(self, candidates: List[Dict], success_rates: Dict, stealth_mode: bool) -> Dict:
        """Scores strategies and selects the best one based on success and stealth."""
        scored_candidates = []
        for strategy in candidates:
            name = strategy['name']

            # Calculate success-based score
            success_score = 10.0
            rate_info = success_rates.get(name)
            if rate_info:
                rate = rate_info['rate']
                # Weight score by success rate (e.g., 0-100)
                success_score = rate * 100
                self.logger.debug(f"Strategy '{name}' has success rate {rate:.2f}, base score: {success_score:.2f}")

            # If in stealth mode, factor in the stealth rating
            if stealth_mode:
                # Stealth rating is 1-10. We weight it heavily.
                stealth_score = strategy.get('stealth_rating', 5) * 10 # Scale to 0-100
                # Weighted average: 40% success, 60% stealth
                final_score = (success_score * 0.4) + (stealth_score * 0.6)
                self.logger.debug(f"Stealth mode active for '{name}'. Success score: {success_score:.2f}, Stealth score: {stealth_score}. Final score: {final_score:.2f}")
            else:
                final_score = success_score

            strategy['score'] = final_score
            scored_candidates.append(strategy)

        return max(scored_candidates, key=lambda x: x['score'])

    def _create_huawei_ma5608t_strategy(self, stealth_mode: bool) -> Dict[str, Any]:
        """Creates a strategy for the Huawei MA5608T, varying by stealth mode."""
        self.logger.info("Creating strategy for Huawei MA5608T.")
        if stealth_mode:
            return {
                "name": "Huawei MA5608T - Stealth Profile Emulation",
                "type": "multi_vector",
                "stealth_rating": 9, # High stealth: slow, gradual changes
                "steps": [
                    {"action": "set_low_snr", "params": {"target_snr_db": 8.0, "duration_s": 600}},
                    {"action": "gradual_profile_spoof", "params": {"target_profile": "17a_stable"}}
                ]
            }
        else:
            return {
                "name": "Huawei MA5608T - Aggressive G.hs & Kernel Spoof",
                "type": "multi_vector",
                "stealth_rating": 2, # Low stealth: noisy, fast, and aggressive
                "steps": [
                    {"action": "ghs_handshake_spoof", "params": {"profile_to_advertise": "35b"}},
                    {"action": "kernel_manipulation", "params": {"target_rate_mbps": 150, "target_distance_m": 20}}
                ]
            }

    def _create_default_huawei_strategy(self, stealth_mode: bool) -> Dict[str, Any]:
        """Default strategy for other Huawei models."""
        self.logger.info("Creating default strategy for Huawei.")
        return {
            "name": "Huawei - Generic Kernel Manipulation",
            "type": "kernel_manipulation",
            "stealth_rating": 7 if stealth_mode else 4, # Adaptive is stealthier than static
            "params": {"target_rate_mbps": 100, "strategy": "adaptive" if stealth_mode else "static"}
        }

    def _create_nokia_alcatel_strategy(self, stealth_mode: bool) -> Dict[str, Any]:
        """Strategy for Nokia/Alcatel-Lucent DSLAMs."""
        self.logger.info("Creating strategy for Nokia/Alcatel.")
        return {
            "name": "Nokia/Alcatel - SNMP Profile Unlock",
            "type": "snmp_manipulation",
            "stealth_rating": 8, # SNMP changes are often less monitored than line drops
            "params": {"profile_oid": "1.3.6.1.4.1.637.61.1.3.1.1.6", "value": "35b_unlocked"}
        }

    def _create_generic_strategy(self) -> Dict[str, Any]:
        """A generic, safe fallback strategy."""
        self.logger.warning("No specific strategy found, using generic fallback.")
        return {
            "name": "Generic - Dynamic SNR Reduction",
            "type": "kernel_manipulation",
            "stealth_rating": 6, # Moderately stealthy, mimics natural line adaptation
            "params": {"strategy": "dynamic_reduce", "target_snr_floor_db": 6.0}
        }