"""
This module contains integration tests for the G.vector exploitation workflow.
"""
import json
from unittest.mock import MagicMock
import pytest

from src.database_manager import DatabaseManager
from src.hal.broadcom import BroadcomDslHal
from src.vectoring_analyzer import VectoringAnalyzer
from src.vectoring_manipulator import VectoringManipulator
from src.entware_ssh import EntwareSSHInterface

@pytest.fixture
def mock_components():
    """Pytest fixture to set up mocked components for the vectoring exploit test."""
    mock_ssh = MagicMock(spec=EntwareSSHInterface)
    # Use read_file to load signatures, as DatabaseManager would
    with open('src/vendor_signatures.json', 'r') as f:
        vendor_signatures = json.load(f)

    hal = BroadcomDslHal(mock_ssh, vendor_signatures)

    # Mock HAL methods to simulate hardware interaction
    def get_mock_pilots():
        print("[SIM] Reading mocked pilot data...")
        return [10, 12, 55, 13, 11, 60, 9]  # Lines 2 and 5 are "hot"

    def get_mock_precoding_matrix():
        print("[SIM] Reading mocked precoding matrix...")
        return [
            [1.0, 0.15, 0.20, 0.05, 0.08, 0.11, 0.09],
            [0.12, 1.0, 0.18, 0.06, 0.05, 0.13, 0.10],
            [0.19, 0.21, 1.0, 0.07, 0.06, 0.15, 0.11],
            [0.05, 0.04, 0.08, 1.0, 0.22, 0.07, 0.14],
            [0.08, 0.06, 0.07, 0.18, 1.0, 0.25, 0.16],
            [0.11, 0.10, 0.12, 0.09, 0.28, 1.0, 0.18],
            [0.09, 0.08, 0.10, 0.11, 0.19, 0.22, 1.0],
        ]

    written_matrix = None
    def set_mock_precoding_matrix(matrix):
        nonlocal written_matrix
        written_matrix = matrix
        print(f"[SIM] Writing new {len(matrix)}x{len(matrix[0])} matrix to hardware.")
        return True

    hal.get_vectoring_pilot_sequence = get_mock_pilots
    hal.get_precoding_matrix = get_mock_precoding_matrix
    hal.set_precoding_matrix = set_mock_precoding_matrix

    mock_dsl_interface = MagicMock()
    mock_dsl_interface.get_hal.return_value = hal

    analyzer = VectoringAnalyzer(ghs_analyzer=None, dsl_interface=mock_dsl_interface, signatures=vendor_signatures)
    manipulator = VectoringManipulator(hal=hal)

    return analyzer, manipulator, lambda: written_matrix

def test_vectoring_exploit_simulation(mock_components):
    """
    Tests the full G.vector exploitation workflow using mocked components.
    """
    analyzer, manipulator, get_written_matrix = mock_components
    our_line_index = 1
    benefit_factor = 0.85

    # Step 1: Analyze pilot tones
    analysis_result = analyzer.analyze_pilot_sequences(threshold_sigma=1.5)
    assert analysis_result is not None
    victim_lines = analysis_result.get("victim_lines", [])
    assert victim_lines == [5] # Corrected based on calculation

    # Step 2: Manipulate the matrix
    success = manipulator.maximize_line_benefit(
        our_line_index=our_line_index,
        victim_lines=victim_lines,
        benefit_factor=benefit_factor
    )
    assert success is True

    # Step 3: Verify the matrix was modified correctly
    written_matrix = get_written_matrix()
    assert written_matrix is not None

    original_matrix = manipulator.hal.get_precoding_matrix()

    # Check that the coefficient for the *actual* victim (line 5) was modified
    assert written_matrix[5][1] == original_matrix[5][1] * benefit_factor

    # Check that the coefficient for line 2 (no longer a victim) was NOT modified
    assert written_matrix[2][1] == original_matrix[2][1]

    # Check that other coefficients were not modified
    assert written_matrix[0][1] == original_matrix[0][1]
    assert written_matrix[1][2] == original_matrix[1][2]
    assert written_matrix[4][3] == original_matrix[4][3]